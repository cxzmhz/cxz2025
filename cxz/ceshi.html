<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js 骨骼动画显示问题解决</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      z-index: 100;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      color: white;
    }

    button {
      padding: 10px 15px;
      margin: 0 5px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background: #45a049;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <div id="info">
    <h2>Three.js 骨骼动画显示问题解决方案</h2>
    <p>角色即使离开视口也会继续播放动画 - 使用对象追踪和禁用视锥体剔除</p>
  </div>
  <div id="controls">
    <button id="playBtn">播放动画</button>
    <button id="stopBtn">停止动画</button>
    <button id="toggleVisibility">切换角色可见性</button>
    <span id="animationState">当前状态: 已停止</span>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

  <script>
    // 全局变量
    let scene, camera, renderer, controls;
    let character, mixer, clock;
    let currentAction = null;

    // 初始化场景
    function init() {
      // 创建场景
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x444444);
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));

      // 创建相机
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.5, 5);

      // 创建渲染器
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      document.getElementById('container').appendChild(renderer.domElement);

      // 添加轨道控制
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1, 0);
      controls.update();

      // 添加灯光
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7.5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);

      // 创建地面
      const floorGeometry = new THREE.PlaneGeometry(20, 20);
      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      // 添加网格辅助工具
      const gridHelper = new THREE.GridHelper(20, 20);
      scene.add(gridHelper);

      // 初始化时钟
      clock = new THREE.Clock();

      // 加载角色模型
      loadCharacter();

      // 添加窗口调整事件监听
      window.addEventListener('resize', onWindowResize);

      // 设置按钮事件
      document.getElementById('playBtn').addEventListener('click', playAnimation);
      document.getElementById('stopBtn').addEventListener('click', stopAnimation);
      document.getElementById('toggleVisibility').addEventListener('click', toggleVisibility);

      // 开始动画循环
      animate();
    }

    // 加载角色模型
    function loadCharacter() {
      const loader = new THREE.GLTFLoader();

      // 注意：这里使用一个简单的几何体代替实际角色模型
      // 在实际应用中，您应该替换为您的模型路径
      // 由于我们不能实际加载外部模型，这里创建一个替代的骨骼动画角色

      // 创建替代的简单角色（实际项目中应使用GLTF模型）
      createPlaceholderCharacter();
    }

    // 创建占位角色（实际项目中应使用GLTFLoader加载真实模型）
    function createPlaceholderCharacter() {
      // 创建骨骼和蒙皮几何体
      const geometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
      const material = new THREE.MeshPhongMaterial({ color: 0x00aaff });
      character = new THREE.Mesh(geometry, material);
      character.castShadow = true;
      character.position.y = 1;

      // 关键步骤：禁用视锥体剔除
      character.frustumCulled = false;

      scene.add(character);

      // 创建虚拟动画混合器
      mixer = new THREE.AnimationMixer(character);

      // 创建简单的动画剪辑（实际项目中应从模型加载）
      const positionKF = new THREE.VectorKeyframeTrack('.position', [0, 1, 2], [
        0, 0, 0,  // 起始位置
        2, 0, 0,  // 中间位置
        0, 0, 0   // 结束位置
      ]);

      const rotationKF = new THREE.QuaternionKeyframeTrack('.quaternion', [0, 1, 2], [
        0, 0, 0, 1,  // 起始旋转
        0, 0, Math.sin(Math.PI / 4), Math.cos(Math.PI / 4),  // 中间旋转
        0, 0, 0, 1   // 结束旋转
      ]);

      const clip = new THREE.AnimationClip('Move', 3, [positionKF, rotationKF]);

      // 存储动画剪辑供后续使用
      character.animations = [clip];

      console.log("占位角色创建完成，在实际项目中应加载真实模型");
    }

    // 播放动画
    function playAnimation() {
      if (!mixer || !character.animations || character.animations.length === 0) return;

      if (currentAction) {
        mixer.stopAllAction();
      }

      currentAction = mixer.clipAction(character.animations[0]);
      currentAction.reset().play();

      document.getElementById('animationState').textContent = "当前状态: 播放中";
    }

    // 停止动画
    function stopAnimation() {
      if (mixer && currentAction) {
        mixer.stopAllAction();
        currentAction = null;

        document.getElementById('animationState').textContent = "当前状态: 已停止";
      }
    }

    // 切换角色可见性
    function toggleVisibility() {
      if (character) {
        character.visible = !character.visible;
        console.log("角色可见性:", character.visible);
      }
    }

    // 窗口大小调整处理
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // 动画循环
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // 更新动画混合器（即使角色不在视口内也会更新）
      if (mixer) {
        mixer.update(delta);
      }

      // 更新控件
      controls.update();

      // 渲染场景
      renderer.render(scene, camera);

      // 即使角色不在视口内也记录其状态
      if (character) {
        // 在实际应用中，这里可以添加额外的逻辑
      }
    }

    // 初始化应用
    init();
  </script>
</body>

</html>